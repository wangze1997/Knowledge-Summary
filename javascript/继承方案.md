# 继承方案

### 原型链继承

原型链继承就是把子类函数的prototype对象指向父类函数的实例对象。

```
Function Father(){}
Father.prototype.name = "tom"
Function Son(){}
Son.prototype = new Father();
var son = new Son()
```

优点

- 即可以继承父类实例对象的属性和方法，也可以继承父类原型对象的属性和方法。
- 简单，易于实现

缺点

- 无法实现多继承
- 子类函数在实例的过程中无法向父类函数传参。

### 构造继承

在子类函数中写下 Father.call(this,参数)。

```
function Father(){}
function Son(){
	Father.call(this,参数)
}
var son = new Son()
```

优点

- 可以实现多继承
- 可以向父类的构造函数中传参

缺点

- 只能继承父类函数的实例对象，不能继承其原型对象

### 组合继承

在子类函数中写下 Father.call(this,参数)，子类函数的prototype对象指向父类函数的实例对象。

```
function Father(){}
function Son(){
	Father.call(this,参数)
}
Son.prototype = new Father();
var son = new Son()
```

优点

- 可以向父类的构造函数中传参
- 即可以继承父类原型对象，又可以继承父类实例对象。

缺点

- 子类的原型对象中有2套相同的属性，只不过前面的把后面的覆盖了。

### 寄生组合式继承

在子类函数中写下 Father.call(this,参数)，创建一个新函数，此函数的原型指向父类函数的原型。再将子类函数的prototype指向此函数的实例对象。

```
function Father(){}
function Son(){
	Father.call(this,参数)
}
function F(){}
F,prototype = Father.prototype
Son.prototype = new F();
Son.prototype.constructor = Son
var son = new Son
```

堪称完美，就是挺复杂。。。